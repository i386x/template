#!/bin/bash
# SPDX-License-Identifier: MIT

set -ex

SCRIPTDIR=$(dirname $0)
TOPDIR=${SCRIPTDIR}/..
CONFIG=${SCRIPTDIR}/config.sh

# Space separated list of molecule scenarios. Set by user in .travis/config.sh
# or as environment variable.
#LSR_MSCENARIOS=

# Include library.
. ${SCRIPTDIR}/utils.sh

# Assemble envlist that should be common for all roles.
lsr_envlist_add 'pyXY' --if-travis-python-in '2.6 2.7 3.6 3.7 3.8' --if-has-unit-tests
lsr_envlist_add 'flake8,pylint' --if-travis-python-in '2.7' --if-has-pyfiles
lsr_envlist_add 'black' --if-travis-python-in '3.6' --if-has-pyfiles
lsr_envlist_add 'molecule' --if-travis-python-is-system-python

# Do a custom changes.
if [[ -f ${CONFIG} ]]; then
  . ${CONFIG}
fi

# Use TOXENV only if we are running on Travis (locally, we use envlist). Since
# tox-travis is not capable of system python detection, we use Bash wrapper
# around tox as workaround. This give us power to also assemble envlists
# dynamically, which is a problem to do in tox.
if [[ "${TRAVIS}" ]]; then
  export TOXENV="${LSR_ENVLIST}"
  echo "TOXENV=${TOXENV}"
fi

# When running tox, the envlist deduction is like follows:
#
#   tox.ini's envlist < [travis] section < TOXENV < tox -e envlist
#
# tox.ini's envlist has lowest priority, tox -e envlist highest. Keep that in
# mind when running tox locally.

# If we are running under Travis CI and TOXENV is empty, skip running the tox.
lsr_set_exitcode 0
if [[ -z "${TRAVIS}" || "${TOXENV}" ]]; then
  (cd ${TRAVIS_BUILD_DIR:-${TOPDIR}} && tox "$@"); lsr_update_exitcode $?
fi
for X in ${LSR_MSCENARIOS}; do
  (cd ${TRAVIS_BUILD_DIR:-${TOPDIR}} && LSR_MSCENARIO=${X} tox -e molecule); lsr_update_exitcode $?
done

lsr_exit
